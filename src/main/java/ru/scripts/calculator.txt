Data object -

{
  "id": "string",
  "productId": "string",
  "productCode": "string",
  "versionNo": "string",
  "packageNo": "string",
  "vars": [
    {
      "varCode": "ph_firstname",
      "varName": "Имя страхователя",
      "varPath": "policyHolder.person.firstName",
      "varType": "IN",
      "varValue": "string"
    }
  ],
  "formulas": [
    {
      "varCode": "ph_firstname",
      "varName": "Имя страхователя",
      "lines": [
        {
          "nr": "string",
          "conditionLeft": {
            "varCode": "ph_firstname",
            "varName": "Имя страхователя"
          },
          "conditionOperator": "string",
          "conditionRight": {
            "varCode": "ph_firstname",
            "varName": "Имя страхователя"
          },
          "expressionResult": {
            "varCode": "ph_firstname",
            "varName": "Имя страхователя"
          },
          "expressionLeft": {
            "varCode": "ph_firstname",
            "varName": "Имя страхователя"
          },
          "expressionOperator": "*",
          "expressionight": {
            "varCode": "ph_firstname",
            "varName": "Имя страхователя"
          },
          "postProcessor": "string"
        }
      ]
    }
  ],
  "coefficients": [
    {
      "varCode": "ph_firstname",
      "varName": "Имя страхователя",
      "columns": [
        {
          "varCode": "ph_firstname",
          "varName": "Имя страхователя",
          "nr": "string",
          "conditionOperator": "string",
          "sortOrder": "string"
        }
      ]
    }
  ]
}

 


create repository for this data object with name pt_calculators
columns (
  id - number, primary key
  productId - number not null
  productCode - number not null
  versionNo - number not null
  packageNo - number not null
  calculator - jsonb
id must be generated before insert, then update ID in json
productId, productCode, versionNo, packageNo take from json

create service CalculateService

create Calculator controller
add get endpoint "/admin/products/{productId}/versions/{versionNo}/packages/{packageNo}/calculator"
call service and returns json from repository by parameters

add Post endpoint "/admin/products/{productId}/versions/{versionNo}/packages/{packageNo}/calculator"
check that no calculator exists for the parameters
if not then create record in reporsitory with empty json and return json in response 
empty json
{
  "id": "string",
  "productId": "string",
  "productCode": "string",
  "versionNo": "string",
  "packageNo": "string",
  "vars": [],
  "formulas": [],
  "coefficients": []
}








// Step 2 //

add Put endpoint "/admin/products/{productId}/versions/{versionNo}/packages/{packageNo}/calculator"
replace data with new on


coefficientData JSON - 
{ "id": 2345,
  "conditionValue": ["234.33", "56666", "DEVICE", "12"],
  "resultValue": "0.12"
} 

coefficientTable JSON -
   [ coefficientData ]

create a repository coefficient_data (id sequence,
  calculator_id number, coefficient_code string, col0 string, col1 string,col2 string,col3 string,col4 string,col5 string,col6 string,col7 string,col8 string,col9 string,col10 string,resultValue number)

create service with methods 
1. insert new record - takes calculator_id, coefficient_code, coefficientData JSON, resultValue. 
generate id from sequence, split array to columns like col0 = conditionValue[0], col1 = conditionValue[1] and so on. 
2. update repository by id. update only col0..col9 and resultValue
3. delete decord by id
4. get record by id
5 . get records as json array by calculator_id, coefficient_code.  select all records with calculator_id, coefficient_code
order by col1,col2,col3,col4,col5 and put it to "data". return coefficientTable JSON
6. replace coefficientTable JSON by calculator_id, coefficient_code. delete all record with calculator_id, coefficient_code, insert new data

create methods in AdminCalculatorController methods
get /admin/calculator/{calculator_id}/coefficients/{coefficient_code}
call service method, returns all records of coefficient. from pp 5

post /admin/calculator/{calculator_id}/coefficients/{coefficient_code}
check if any record with calculator_id, coefficient_code exists then return error
if not, insert all records

put /admin/calculator/{calculator_id}/coefficients/{coefficient_code}
replace all records with calculator_id, coefficient_code


// step3 //
create domain model in package calculator from the json  from this file


// step 4

JdbcTemplate  must be used to data acsses
Do not use java.sql directly

in coefficientService create method String getCoefficientValue(calculatorId, coefficientCode, map<String, String>, List<CoefficientColumn> )
bild SQL string and order_by string
make a loop by List<CoefficientColumn> 
  take varCode, nr, conditionOperator,sortOrder 
  varValue = get value from map<String, String> by key varCode. if key not found return null;
  SQL_string += "AND COL"+ nr +  conditionOperator + varValue
  if sortOrder = ASC or DESC then order_by_string += "COL"+nr + sordOrder
final SQL_string = "select result_value from coefficient_data where calculator_id = calculatorId and coefficient_code = coefficientCode " + SQL_string
of order_by_string != "" then sql_string += order by string
make sql call with sql_string
return first record result_value
when no data found or other exception then return null;



//step 5

create method runCalculator(Long productId, Integer versionNo, Integer packageNo, Map<String,String>) in CalculatorServise
 get CalculatorModel with getCalculatorModel(Long productId, Integer versionNo, Integer packageNo) 
 make loop by Map 
   find varDef in calculatorModels.vars by key, if found then set varValue to value from map
get  formulas [0]
make loop by lines order by nr acs
for each row if conditionLeft and conditionOperator is not null then calculate boolean result for (conditionLeft  conditionOperator)
or (conditionLeft conditionOperator  conditionRight) if conditionRight is not empty
if result is false then go to next iteration

get valueLft from Map by key = expressionLeft
if expressionRight is not null then get valueRight from Map by key = expressionRight
result = valueLeft expressionOperator expressionRight
if postProcessor is not null then switch by name and call function, for instance round2(result) rounds to 2 digits

put result by key = expressionResult into Map

conditionLeft, conditionRight, valueLeft and valueRight may be number or string.

create end point test/main2 in TestControler to test this method